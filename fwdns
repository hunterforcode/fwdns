#!/usr/bin/env node
'use strict';

if (process.env.NODE_ENV !== 'production'){
  try { require('longjohn'); } catch (e) {} }

const debug = require('debug')('fwdns:server');
const dnsd = require('./dnsd/named');
const dns = require('./dns/dns');
const Zone = require('./zone');
const consts = require('./packet/').consts;
const ip6 = require('ip6');
const NodeCache = require('node-cache');
const cache = new NodeCache({ useClones: false });

function collectZone(zone, zones) {
  if (zone.endsWith('.json')) {
    zone = require(zone);
    if (zone && Array.isArray(zone.hosts) && Array.isArray(zone.names)) {
      zones.push(new Zone(zone.hosts, zone.names));
    }
  } else {
    zones.push(zone);
  }
  return zones;
}

function collectLocalZone(zone, zones) {
  if (zone.endsWith('.json')) {
    zone = require(zone);
    if (zone) {
      Object.assign(zones, zone);
    }
  }
  return zones;
}

const option = require('commander')
  .version(require('./package.json').version)
  .option('-p, --port [6666]', 'Port to bind', val => parseInt(val), 6666)
  .option('-l, --listen [127.0.0.1]', 'Address to listen', '127.0.0.1')
  .option('-z, --zone <8.8.8.8>', 'Default zone', collectZone, [])
  .option('-t, --timeout [5000]',
    'Timeout forwarding requests',
     val => parseInt(val), 5000)
  .option('-f, --forward-zone [/path/to/forward/zone.json]',
    'Forward zone setting, {"hosts": ["8.8.8.8"], "names": ["google.com"]}',
     collectZone, [])
  .option('-s, --local-zone [/path/to/local/zone.json]',
    'Local zone setting, {"abc.com": "127.0.0.1"}',
     collectLocalZone, [])
  .parse(process.argv);

if (option.zone.length === 0) {
  console.error('a default zone is required. try `fwdns -z 8.8.8.8`');
  process.exit(1);
}

const SupportTypes = [
  'A', 'MX', 'CNAME', 'TXT', 'PTR',
  'AAAA', 'NS', 'SOA', 'SRV'
  //, 'DS' // unsupported by native-dns-packet
];

const server = dnsd.createServer((req, res) => {
  const question = req.question[0], hostname = question.name;
  const start = Date.now();
  const tag = `[${pad(5, req.id)}/${pad(4, req.connection.type, ' ')}]`;
  let timeStamp = [
    tag, req.opcode, hostname, question.class, question.type].join(' ');

  // TODO unsupported due to dnsd's broken implementation.
  if (SupportTypes.indexOf(question.type) === -1) {
    debug(timeStamp + ` +${Date.now() -  start}ms`);
    res.responseCode = 2;
    return res.end();
  }

  const cached = get(question);
  if (cached != null) {
    const timeLeft = parseInt((ttl(question) - Date.now()) / 1000);
    debug(timeStamp + ` via cache (ttl: ${timeLeft}) +${Date.now() -  start}ms`);
    copy(cached, res, ['authority', 'answer'], (rec) => {
      rec.ttl = timeLeft;
      return rec;
    });
    res.end();
    return;
  }

  let local = option.localZone[question.name];
  if (local) {
    if (!Array.isArray(local)) local = [local];
    res.answer = local.map(val => {
      return {
        name: question.name,
        type: 'A',
        class: 'IN',
        data: val,
        ttl: 3600
      }
    });
    debug(timeStamp + ` via local +${Date.now() -  start}ms`);
    save(res);
    return res.end();;
  }

  const server = {};
  for (let fwz of option.forwardZone) {
    if (fwz.match(question.name)) {
      server.address = fwz.hosts[0];
      break;
    }
  }

  if (!server.address) server.address = option.zone[0];

  timeStamp += ' via ' + server.address;

  let address = server.address.split(':');
  if (address.length > 1) {
    server.port = address[1];
    server.address = address[0];
  }

  question.class = consts.NAME_TO_QCLASS[question.class] || 1;

  const forwardReq = dns.Request({
    question: dns.Question(question),
    server: server,
    timeout: option.timeout,
  });

  forwardReq.on('timeout', () => {
    res.responseCode = 2;
    debug('Timeout in making request');
  });

  forwardReq.on('error', err => {
    res.responseCode = 2;
    debug('forward error', err);
  });

  forwardReq.on('message', (err, message) => {
    if (err) {
      res.responseCode = 2;
      debug('forward error', err);
      return;
    }
    ['authority', 'answer'].forEach(k => {
      if (message[k]) {
        res[k] = message[k]
          .filter(v => v.type === consts.nameToQtype(question.type))
          .map(convert);
      }
    });
  });

  forwardReq.on('end', () => {
    debug(timeStamp + ` +${Date.now() -  start}ms`);
    save(question, res);
    res.end();
  });

  forwardReq.send();
});

function pad(n, m, holder = '0') {
  return String(Array(n + 1).join(holder) + m).slice(-n);
}

// convert from node-dns to dnsd
function convert(rec) {
  rec.type = consts.qtypeToName(rec.type);
  rec.class = consts.QCLASS_TO_NAME[rec.class] || 'IN';
  switch (rec.type) {
    case 'A':
      rec.data = rec.address;
      break;
    case 'AAAA':
      rec.data = ip6.normalize(rec.address);
      break;
    case 'CNAME':
      rec.data = [
        rec.primary,
        rec.admin,
        rec.serial,
        rec.refresh,
        rec.retry,
        rec.expiration,
        rec.minimum
      ];
      break;
    case 'MX':
      rec.data = [rec.priority, rec.exchange];
      break;
    case 'TXT':
    case 'SPF':
      rec.data = rec.data;
      break;
    case 'SOA':
      rec.data = {
        rname: rec.primary,
        mname: rec.admin,
        serial: rec.serial,
        refresh: rec.refresh,
        retry: rec.retry,
        expire: rec.expiration,
        ttl: rec.minimum
      };
      break;
    case 'SRV':
      rec.data = {};
      ['priority', 'weight', 'port', 'target'].forEach(key => {
        rec.data[key] = rec[key];
      });
      break;
  }
  return rec;
}

function save(question, res) {
  const key = `${question.name} ${question.type}`;
  const o = res.authority.length > 0 ? res.authority : res.answer;
  const ttl = o.map(v => v.ttl);
  cache.set(key, copy(res), ttl.length > 0 ? ttl[0] : 600);
}

function get(question) {
  const key = `${question.name} ${question.type}`;
  return cache.get(key);
}

function ttl(question) {
  const key = `${question.name} ${question.type}`;
  return cache.getTtl(key);
}

function copy(from, to = {}, keys = ['authority', 'answer'], mapper) {
  keys.forEach(k => {
    if (from[k]) {
      to[k] = mapper ? from[k].map(v => mapper(v)) : from[k];
    }
  });
  return to;
}

server.listen(option.port, option.address, () => {
  debug(`start listening to ${option.address || ''}:${option.port}.`)
});
