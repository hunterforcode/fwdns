#!/usr/bin/env node
'use strict';

if (process.env.NODE_ENV !== 'production'){
  try { require('longjohn'); } catch (e) {} }

const debug = require('debug')('fwdns:server');
const dnsd = require('./dnsd/named');
const dns = require('./dns/dns');
const Zone = require('./zone');
const consts = require('./packet/').consts;
const ip6 = require('ip6');

function collectZone(zone, zones) {
  if (zone.endsWith('.json')) {
    zone = require(zone);
    if (zone && Array.isArray(zone.hosts) && Array.isArray(zone.names)) {
      zones.push(new Zone(name.hosts, zone.names));
    }
  } else {
    zones.push(zone);
  }
  return zones;
}

const option = require('commander')
  .version(require('./package.json').version)
  .option('-p, --port [6666]', 'Port to bind', val => parseInt(val), 6666)
  .option('-l, --listen [127.0.0.1]', 'Address to listen', '127.0.0.1')
  .option('-z, --zone <8.8.8.8>', 'Default zone', collectZone, [])
  .option('-t, --timeout [5000]',
    'Timeout forwarding requests',
     val => parseInt(val), 5000)
  .option('-f, --forward-zone [/path/to/forward/zone.json]',
    'Forward zone setting, {"hosts": ["8.8.8.8"], "names": ["google.com"]}',
     collectZone, [])
  .option('-l, --local-zone [/path/to/local/zone.json]',
    'Local zone setting, {"hosts": ["127.0.0.1"], "names": ["abc.com"]}',
     collectZone, [])
  .parse(process.argv);

const SupportTypes = [
  'A', 'MX', 'CNAME', 'TXT', 'PTR',
  'AAAA', 'NS', 'SOA', 'SRV'
  //, 'DS' // unsupported by native-dns-packet
];

const server = dnsd.createServer((req, res) => {
  const question = req.question[0], hostname = question.name;
  const start = Date.now();
  const tag = `[${pad(5, req.id)}/${pad(4, req.connection.type, ' ')}]`;
  const timeStamp = [
    tag, req.opcode, hostname, question.class, question.type].join(' ');

  // TODO unsupported due to dnsd's broken implementation.
  if (SupportTypes.indexOf(question.type) === -1) {
    debug(timeStamp + ` +${Date.now() -  start}ms`);
    res.responseCode = 2;
    return res.end();
  }

  question.class = consts.NAME_TO_QCLASS[question.class] || 1;

  const forwardReq = dns.Request({
    question: dns.Question(question),
    server: { address: option.zone[0] },
    timeout: option.timeout,
  });

  forwardReq.on('timeout', () => {
    res.responseCode = 2;
    debug('Timeout in making request');
  });

  forwardReq.on('error', err => {
    res.responseCode = 2;
    debug('forward error', err);
  });

  forwardReq.on('message', (err, message) => {
    const anw = question.type == 'CNAME' ? message.authority : message.answer;
    res.answer = anw.map((rec) => {
      rec.type = consts.qtypeToName(rec.type);
      rec.class = consts.QCLASS_TO_NAME[rec.class] || 'IN';
      switch (rec.type) {
        case 'A':
          rec.data = rec.address;
          break;
        case 'AAAA':
          rec.data = ip6.normalize(rec.address);
          break;
        case 'CNAME':
          rec.data = [
            rec.primary,
            rec.admin,
            rec.serial,
            rec.refresh,
            rec.retry,
            rec.expiration,
            rec.minimum
          ];
          break;
        case 'MX':
          rec.data = [rec.priority, rec.exchange];
          break;
        case 'TXT':
        case 'SPF':
          rec.data = rec.data;
          break;
        case 'SOA':
          rec.data = {
            rname: rec.primary,
            mname: rec.admin,
            serial: rec.serial,
            refresh: rec.refresh,
            retry: rec.retry,
            expire: rec.expiration,
            ttl: rec.minimum
          };
          break;
        case 'SRV':
          rec.data = rec;
          break;
      }
      return rec;
    });
  });

  forwardReq.on('end', () => {
    debug(timeStamp + ` +${Date.now() -  start}ms`);
    res.end();
  });

  forwardReq.send();
});

function pad(n, m, holder = '0') {
  return String(Array(n + 1).join(holder) + m).slice(-n);
}

server.listen(option.port, option.address, () => {
  debug(`start listening to ${option.address || ''}:${option.port}.`)
});
